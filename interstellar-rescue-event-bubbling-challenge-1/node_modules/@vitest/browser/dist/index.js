import { createDebugger, isFileServingAllowed, getFilePoolName, resolveApiServerConfig, resolveFsAllow, distDir, createServer } from 'vitest/node';
import fs, { existsSync, readdirSync, readFileSync, promises, lstatSync } from 'node:fs';
import { WebSocketServer } from 'ws';
import { builtinModules, createRequire } from 'node:module';
import { readFile as readFile$1, mkdir } from 'node:fs/promises';
import { fileURLToPath } from 'node:url';
import { createDefer, slash, toArray } from '@vitest/utils';
import { parseErrorStacktrace, parseStacktrace } from '@vitest/utils/source-map';
import sirv from 'sirv';
import { defaultBrowserPort, coverageConfigDefaults } from 'vitest/config';
import { P as PlaywrightBrowserProvider, W as WebdriverBrowserProvider } from './webdriver-BdVqnfdE.js';
import { resolve as resolve$1, dirname as dirname$1, normalize as normalize$1 } from 'node:path';
import MagicString from 'magic-string';
import { esmWalker } from '@vitest/utils/ast';
import crypto from 'node:crypto';
import * as nodeos from 'node:os';

const _DRIVE_LETTER_START_RE = /^[A-Za-z]:\//;
function normalizeWindowsPath(input = "") {
  if (!input) {
    return input;
  }
  return input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE, (r) => r.toUpperCase());
}

const _UNC_REGEX = /^[/\\]{2}/;
const _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
const _DRIVE_LETTER_RE = /^[A-Za-z]:$/;
const _ROOT_FOLDER_RE = /^\/([A-Za-z]:)?$/;
const normalize = function(path) {
  if (path.length === 0) {
    return ".";
  }
  path = normalizeWindowsPath(path);
  const isUNCPath = path.match(_UNC_REGEX);
  const isPathAbsolute = isAbsolute(path);
  const trailingSeparator = path[path.length - 1] === "/";
  path = normalizeString(path, !isPathAbsolute);
  if (path.length === 0) {
    if (isPathAbsolute) {
      return "/";
    }
    return trailingSeparator ? "./" : ".";
  }
  if (trailingSeparator) {
    path += "/";
  }
  if (_DRIVE_LETTER_RE.test(path)) {
    path += "/";
  }
  if (isUNCPath) {
    if (!isPathAbsolute) {
      return `//./${path}`;
    }
    return `//${path}`;
  }
  return isPathAbsolute && !isAbsolute(path) ? `/${path}` : path;
};
const join = function(...arguments_) {
  if (arguments_.length === 0) {
    return ".";
  }
  let joined;
  for (const argument of arguments_) {
    if (argument && argument.length > 0) {
      if (joined === void 0) {
        joined = argument;
      } else {
        joined += `/${argument}`;
      }
    }
  }
  if (joined === void 0) {
    return ".";
  }
  return normalize(joined.replace(/\/\/+/g, "/"));
};
function cwd() {
  if (typeof process !== "undefined" && typeof process.cwd === "function") {
    return process.cwd().replace(/\\/g, "/");
  }
  return "/";
}
const resolve = function(...arguments_) {
  arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {
    const path = index >= 0 ? arguments_[index] : cwd();
    if (!path || path.length === 0) {
      continue;
    }
    resolvedPath = `${path}/${resolvedPath}`;
    resolvedAbsolute = isAbsolute(path);
  }
  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute && !isAbsolute(resolvedPath)) {
    return `/${resolvedPath}`;
  }
  return resolvedPath.length > 0 ? resolvedPath : ".";
};
function normalizeString(path, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let char = null;
  for (let index = 0; index <= path.length; ++index) {
    if (index < path.length) {
      char = path[index];
    } else if (char === "/") {
      break;
    } else {
      char = "/";
    }
    if (char === "/") {
      if (lastSlash === index - 1 || dots === 1) ; else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
            }
            lastSlash = index;
            dots = 0;
            continue;
          } else if (res.length > 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = index;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path.slice(lastSlash + 1, index)}`;
        } else {
          res = path.slice(lastSlash + 1, index);
        }
        lastSegmentLength = index - lastSlash - 1;
      }
      lastSlash = index;
      dots = 0;
    } else if (char === "." && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
const isAbsolute = function(p) {
  return _IS_ABSOLUTE_RE.test(p);
};
const _EXTNAME_RE = /.(\.[^./]+)$/;
const extname = function(p) {
  const match = _EXTNAME_RE.exec(normalizeWindowsPath(p));
  return match && match[1] || "";
};
const relative = function(from, to) {
  const _from = resolve(from).replace(_ROOT_FOLDER_RE, "$1").split("/");
  const _to = resolve(to).replace(_ROOT_FOLDER_RE, "$1").split("/");
  if (_to[0][1] === ":" && _from[0][1] === ":" && _from[0] !== _to[0]) {
    return _to.join("/");
  }
  const _fromCopy = [..._from];
  for (const segment of _fromCopy) {
    if (_to[0] !== segment) {
      break;
    }
    _from.shift();
    _to.shift();
  }
  return [..._from.map(() => ".."), ..._to].join("/");
};
const dirname = function(p) {
  const segments = normalizeWindowsPath(p).replace(/\/$/, "").split("/").slice(0, -1);
  if (segments.length === 1 && _DRIVE_LETTER_RE.test(segments[0])) {
    segments[0] += "/";
  }
  return segments.join("/") || (isAbsolute(p) ? "/" : ".");
};
const basename = function(p, extension) {
  const lastSegment = normalizeWindowsPath(p).split("/").pop();
  return extension && lastSegment.endsWith(extension) ? lastSegment.slice(0, -extension.length) : lastSegment;
};

const DEFAULT_TIMEOUT = 6e4;
function defaultSerialize(i) {
  return i;
}
const defaultDeserialize = defaultSerialize;
const { clearTimeout, setTimeout } = globalThis;
const random = Math.random.bind(Math);
function createBirpc(functions, options) {
  const {
    post,
    on,
    eventNames = [],
    serialize = defaultSerialize,
    deserialize = defaultDeserialize,
    resolver,
    timeout = DEFAULT_TIMEOUT
  } = options;
  const rpcPromiseMap = /* @__PURE__ */ new Map();
  let _promise;
  const rpc = new Proxy({}, {
    get(_, method) {
      if (method === "$functions")
        return functions;
      if (method === "then" && !eventNames.includes("then") && !("then" in functions))
        return void 0;
      const sendEvent = (...args) => {
        post(serialize({ m: method, a: args, t: "q" }));
      };
      if (eventNames.includes(method)) {
        sendEvent.asEvent = sendEvent;
        return sendEvent;
      }
      const sendCall = async (...args) => {
        await _promise;
        return new Promise((resolve, reject) => {
          const id = nanoid();
          let timeoutId;
          if (timeout >= 0) {
            timeoutId = setTimeout(() => {
              try {
                options.onTimeoutError?.(method, args);
                throw new Error(`[birpc] timeout on calling "${method}"`);
              } catch (e) {
                reject(e);
              }
              rpcPromiseMap.delete(id);
            }, timeout);
            if (typeof timeoutId === "object")
              timeoutId = timeoutId.unref?.();
          }
          rpcPromiseMap.set(id, { resolve, reject, timeoutId });
          post(serialize({ m: method, a: args, i: id, t: "q" }));
        });
      };
      sendCall.asEvent = sendEvent;
      return sendCall;
    }
  });
  _promise = on(async (data, ...extra) => {
    const msg = deserialize(data);
    if (msg.t === "q") {
      const { m: method, a: args } = msg;
      let result, error;
      const fn = resolver ? resolver(method, functions[method]) : functions[method];
      if (!fn) {
        error = new Error(`[birpc] function "${method}" not found`);
      } else {
        try {
          result = await fn.apply(rpc, args);
        } catch (e) {
          error = e;
        }
      }
      if (msg.i) {
        if (error && options.onError)
          options.onError(error, method, args);
        post(serialize({ t: "s", i: msg.i, r: result, e: error }), ...extra);
      }
    } else {
      const { i: ack, r: result, e: error } = msg;
      const promise = rpcPromiseMap.get(ack);
      if (promise) {
        clearTimeout(promise.timeoutId);
        if (error)
          promise.reject(error);
        else
          promise.resolve(result);
      }
      rpcPromiseMap.delete(ack);
    }
  });
  return rpc;
}
const urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
function nanoid(size = 21) {
  let id = "";
  let i = size;
  while (i--)
    id += urlAlphabet[random() * 64 | 0];
  return id;
}

/// <reference types="../types/index.d.ts" />

// (c) 2020-present Andrea Giammarchi

const {parse: $parse, stringify: $stringify} = JSON;
const {keys} = Object;

const Primitive = String;   // it could be Number
const primitive = 'string'; // it could be 'number'

const ignore = {};
const object = 'object';

const noop = (_, value) => value;

const primitives = value => (
  value instanceof Primitive ? Primitive(value) : value
);

const Primitives = (_, value) => (
  typeof value === primitive ? new Primitive(value) : value
);

const revive = (input, parsed, output, $) => {
  const lazy = [];
  for (let ke = keys(output), {length} = ke, y = 0; y < length; y++) {
    const k = ke[y];
    const value = output[k];
    if (value instanceof Primitive) {
      const tmp = input[value];
      if (typeof tmp === object && !parsed.has(tmp)) {
        parsed.add(tmp);
        output[k] = ignore;
        lazy.push({k, a: [input, parsed, tmp, $]});
      }
      else
        output[k] = $.call(output, k, tmp);
    }
    else if (output[k] !== ignore)
      output[k] = $.call(output, k, value);
  }
  for (let {length} = lazy, i = 0; i < length; i++) {
    const {k, a} = lazy[i];
    output[k] = $.call(output, k, revive.apply(null, a));
  }
  return output;
};

const set = (known, input, value) => {
  const index = Primitive(input.push(value) - 1);
  known.set(value, index);
  return index;
};

/**
 * Converts a specialized flatted string into a JS value.
 * @param {string} text
 * @param {(this: any, key: string, value: any) => any} [reviver]
 * @returns {any}
 */
const parse = (text, reviver) => {
  const input = $parse(text, Primitives).map(primitives);
  const value = input[0];
  const $ = reviver || noop;
  const tmp = typeof value === object && value ?
              revive(input, new Set, value, $) :
              value;
  return $.call({'': tmp}, '', tmp);
};

/**
 * Converts a JS value into a specialized flatted string.
 * @param {any} value
 * @param {((this: any, key: string, value: any) => any) | (string | number)[] | null | undefined} [replacer]
 * @param {string | number | undefined} [space]
 * @returns {string}
 */
const stringify = (value, replacer, space) => {
  const $ = replacer && typeof replacer === object ?
            (k, v) => (k === '' || -1 < replacer.indexOf(k) ? v : void 0) :
            (replacer || noop);
  const known = new Map;
  const input = [];
  const output = [];
  let i = +set(known, input, $.call({'': value}, '', value));
  let firstRun = !i;
  while (i < input.length) {
    firstRun = true;
    output[i] = $stringify(input[i++], replace, space);
  }
  return '[' + output.join(',') + ']';
  function replace(key, value) {
    if (firstRun) {
      firstRun = !firstRun;
      return value;
    }
    const after = $.call(this, key, value);
    switch (typeof after) {
      case object:
        if (after === null) return after;
      case primitive:
        return known.get(after) || set(known, input, after);
    }
    return after;
  }
};

async function resolveMock(project, rawId, importer, hasFactory) {
  const { id, fsPath, external } = await resolveId(project, rawId, importer);
  if (hasFactory) {
    const needsInteropMap = viteDepsInteropMap(project.browser.vite.config);
    const needsInterop = needsInteropMap?.get(fsPath) ?? false;
    return { type: "factory", resolvedId: id, needsInterop };
  }
  const mockPath = resolveMockPath(project.config.root, fsPath, external);
  return {
    type: mockPath === null ? "automock" : "redirect",
    mockPath,
    resolvedId: id
  };
}
async function resolveId(project, rawId, importer) {
  const resolved = await project.browser.vite.pluginContainer.resolveId(
    rawId,
    importer,
    {
      ssr: false
    }
  );
  return resolveModule(project, rawId, resolved);
}
async function resolveModule(project, rawId, resolved) {
  const id = resolved?.id || rawId;
  const external = !isAbsolute(id) || isModuleDirectory(project.config, id) ? rawId : null;
  return {
    id,
    fsPath: cleanUrl(id),
    external
  };
}
function isModuleDirectory(config, path) {
  const moduleDirectories = config.server.deps?.moduleDirectories || [
    "/node_modules/"
  ];
  return moduleDirectories.some((dir) => path.includes(dir));
}
function resolveMockPath(root, mockPath, external) {
  const path = external || mockPath;
  if (external || isNodeBuiltin(mockPath) || !existsSync(mockPath)) {
    const mockDirname = dirname(path);
    const mockFolder = join(
      root,
      "__mocks__",
      mockDirname
    );
    if (!existsSync(mockFolder)) {
      return null;
    }
    const files = readdirSync(mockFolder);
    const baseOriginal = basename(path);
    for (const file of files) {
      const baseFile = basename(file, extname(file));
      if (baseFile === baseOriginal) {
        return resolve(mockFolder, file);
      }
    }
    return null;
  }
  const dir = dirname(path);
  const baseId = basename(path);
  const fullPath = resolve(dir, "__mocks__", baseId);
  return existsSync(fullPath) ? fullPath : null;
}
const prefixedBuiltins = /* @__PURE__ */ new Set(["node:test"]);
const builtins = /* @__PURE__ */ new Set([
  ...builtinModules,
  "assert/strict",
  "diagnostics_channel",
  "dns/promises",
  "fs/promises",
  "path/posix",
  "path/win32",
  "readline/promises",
  "stream/consumers",
  "stream/promises",
  "stream/web",
  "timers/promises",
  "util/types",
  "wasi"
]);
const NODE_BUILTIN_NAMESPACE = "node:";
function isNodeBuiltin(id) {
  if (prefixedBuiltins.has(id)) {
    return true;
  }
  return builtins.has(
    id.startsWith(NODE_BUILTIN_NAMESPACE) ? id.slice(NODE_BUILTIN_NAMESPACE.length) : id
  );
}
const postfixRE = /[?#].*$/;
function cleanUrl(url) {
  return url.replace(postfixRE, "");
}
const metadata = /* @__PURE__ */ new WeakMap();
function viteDepsInteropMap(config) {
  if (metadata.has(config)) {
    return metadata.get(config);
  }
  const cacheDirPath = getDepsCacheDir(config);
  const metadataPath = resolve(cacheDirPath, "_metadata.json");
  if (!existsSync(metadataPath)) {
    return null;
  }
  const { optimized } = JSON.parse(readFileSync(metadataPath, "utf-8"));
  const needsInteropMap = /* @__PURE__ */ new Map();
  for (const name in optimized) {
    const dep = optimized[name];
    const file = resolve(cacheDirPath, dep.file);
    needsInteropMap.set(file, dep.needsInterop);
  }
  metadata.set(config, needsInteropMap);
  return needsInteropMap;
}
function getDepsCacheDir(config) {
  return resolve(config.cacheDir, "deps");
}

const debug$1 = createDebugger("vitest:browser:api");
const BROWSER_API_PATH = "/__vitest_browser_api__";
const VALID_ID_PREFIX = "/@id/";
function setupBrowserRpc(server) {
  const project = server.project;
  const vite = server.vite;
  const ctx = project.ctx;
  const wss = new WebSocketServer({ noServer: true });
  vite.httpServer?.on("upgrade", (request, socket, head) => {
    if (!request.url) {
      return;
    }
    const { pathname, searchParams } = new URL(request.url, "http://localhost");
    if (pathname !== BROWSER_API_PATH) {
      return;
    }
    const type = searchParams.get("type") ?? "tester";
    const sessionId = searchParams.get("sessionId") ?? "0";
    wss.handleUpgrade(request, socket, head, (ws) => {
      wss.emit("connection", ws, request);
      const rpc = setupClient(sessionId, ws);
      const state = server.state;
      const clients = type === "tester" ? state.testers : state.orchestrators;
      clients.set(sessionId, rpc);
      debug$1?.("[%s] Browser API connected to %s", sessionId, type);
      ws.on("close", () => {
        debug$1?.("[%s] Browser API disconnected from %s", sessionId, type);
        clients.delete(sessionId);
        server.state.removeCDPHandler(sessionId);
      });
    });
  });
  function checkFileAccess(path) {
    if (!isFileServingAllowed(path, vite)) {
      throw new Error(
        `Access denied to "${path}". See Vite config documentation for "server.fs": https://vitejs.dev/config/server-options.html#server-fs-strict.`
      );
    }
  }
  function setupClient(sessionId, ws) {
    const rpc = createBirpc(
      {
        async onUnhandledError(error, type) {
          ctx.state.catchError(error, type);
        },
        async onCollected(files) {
          ctx.state.collectFiles(project, files);
          await ctx.report("onCollected", files);
        },
        async onTaskUpdate(packs) {
          ctx.state.updateTasks(packs);
          await ctx.report("onTaskUpdate", packs);
        },
        onAfterSuiteRun(meta) {
          ctx.coverageProvider?.onAfterSuiteRun(meta);
        },
        sendLog(log) {
          return ctx.report("onUserConsoleLog", log);
        },
        resolveSnapshotPath(testPath) {
          return ctx.snapshot.resolvePath(testPath);
        },
        resolveSnapshotRawPath(testPath, rawPath) {
          return ctx.snapshot.resolveRawPath(testPath, rawPath);
        },
        snapshotSaved(snapshot) {
          ctx.snapshot.add(snapshot);
        },
        async readSnapshotFile(snapshotPath) {
          checkFileAccess(snapshotPath);
          if (!existsSync(snapshotPath)) {
            return null;
          }
          return promises.readFile(snapshotPath, "utf-8");
        },
        async saveSnapshotFile(id, content) {
          checkFileAccess(id);
          await promises.mkdir(dirname(id), { recursive: true });
          return promises.writeFile(id, content, "utf-8");
        },
        async removeSnapshotFile(id) {
          checkFileAccess(id);
          if (!existsSync(id)) {
            throw new Error(`Snapshot file "${id}" does not exist.`);
          }
          return promises.unlink(id);
        },
        getBrowserFileSourceMap(id) {
          const mod = server.vite.moduleGraph.getModuleById(id);
          return mod?.transformResult?.map;
        },
        onCancel(reason) {
          ctx.cancelCurrentRun(reason);
        },
        async resolveId(id, importer) {
          const resolved = await vite.pluginContainer.resolveId(
            id,
            importer,
            {
              ssr: false
            }
          );
          if (!resolved) {
            return null;
          }
          const isOptimized = resolved.id.startsWith(withTrailingSlash(vite.config.cacheDir));
          let url;
          const root = vite.config.root;
          if (resolved.id.startsWith(withTrailingSlash(root))) {
            url = resolved.id.slice(root.length);
          } else if (resolved.id !== "/@react-refresh" && isAbsolute(resolved.id) && existsSync(cleanUrl(resolved.id))) {
            url = join("/@fs/", resolved.id);
          } else {
            url = resolved.id;
          }
          if (url[0] !== "." && url[0] !== "/") {
            url = id.startsWith(VALID_ID_PREFIX) ? id : VALID_ID_PREFIX + id.replace("\0", "__x00__");
          }
          return {
            id: resolved.id,
            url,
            optimized: isOptimized
          };
        },
        debug(...args) {
          ctx.logger.console.debug(...args);
        },
        getCountOfFailedTests() {
          return ctx.state.getCountOfFailedTests();
        },
        async triggerCommand(contextId, command, testPath, payload) {
          debug$1?.('[%s] Triggering command "%s"', contextId, command);
          const provider = server.provider;
          if (!provider) {
            throw new Error("Commands are only available for browser tests.");
          }
          const commands = project.config.browser?.commands;
          if (!commands || !commands[command]) {
            throw new Error(`Unknown command "${command}".`);
          }
          if (provider.beforeCommand) {
            await provider.beforeCommand(command, payload);
          }
          const context = Object.assign(
            {
              testPath,
              project,
              provider,
              contextId
            },
            provider.getCommandsContext(contextId)
          );
          let result;
          try {
            result = await commands[command](context, ...payload);
          } finally {
            if (provider.afterCommand) {
              await provider.afterCommand(command, payload);
            }
          }
          return result;
        },
        finishBrowserTests(contextId) {
          debug$1?.("[%s] Finishing browser tests for context", contextId);
          return server.state.getContext(contextId)?.resolve();
        },
        resolveMock(rawId, importer, hasFactory) {
          return resolveMock(project, rawId, importer, hasFactory);
        },
        invalidate(ids) {
          ids.forEach((id) => {
            const moduleGraph = server.vite.moduleGraph;
            const module = moduleGraph.getModuleById(id);
            if (module) {
              moduleGraph.invalidateModule(module, /* @__PURE__ */ new Set(), Date.now(), true);
            }
          });
        },
        // CDP
        async sendCdpEvent(contextId, event, payload) {
          const cdp = await server.ensureCDPHandler(contextId, sessionId);
          return cdp.send(event, payload);
        },
        async trackCdpEvent(contextId, type, event, listenerId) {
          const cdp = await server.ensureCDPHandler(contextId, sessionId);
          cdp[type](event, listenerId);
        }
      },
      {
        post: (msg) => ws.send(msg),
        on: (fn) => ws.on("message", fn),
        eventNames: ["onCancel", "cdpEvent"],
        serialize: (data) => stringify(data, stringifyReplace),
        deserialize: parse,
        onTimeoutError(functionName) {
          throw new Error(`[vitest-api]: Timeout calling "${functionName}"`);
        }
      }
    );
    ctx.onCancel((reason) => rpc.onCancel(reason));
    return rpc;
  }
}
function cloneByOwnProperties(value) {
  return Object.getOwnPropertyNames(value).reduce(
    (clone, prop) => ({
      ...clone,
      [prop]: value[prop]
    }),
    {}
  );
}
function stringifyReplace(key, value) {
  if (value instanceof Error) {
    const cloned = cloneByOwnProperties(value);
    return {
      name: value.name,
      message: value.message,
      stack: value.stack,
      ...cloned
    };
  } else {
    return value;
  }
}
function withTrailingSlash(path) {
  if (path[path.length - 1] !== "/") {
    return `${path}/`;
  }
  return path;
}

class BrowserServerState {
  orchestrators = /* @__PURE__ */ new Map();
  testers = /* @__PURE__ */ new Map();
  cdps = /* @__PURE__ */ new Map();
  contexts = /* @__PURE__ */ new Map();
  getContext(contextId) {
    return this.contexts.get(contextId);
  }
  createAsyncContext(method, contextId, files) {
    const defer = createDefer();
    this.contexts.set(contextId, {
      files,
      method,
      resolve: () => {
        defer.resolve();
        this.contexts.delete(contextId);
      },
      reject: defer.reject
    });
    return defer;
  }
  async removeCDPHandler(sessionId) {
    this.cdps.delete(sessionId);
  }
}

function replacer(code, values) {
  return code.replace(/\{\s*(\w+)\s*\}/g, (_, key) => values[key] ?? "");
}
const builtinProviders = ["webdriverio", "playwright", "preview"];
async function getBrowserProvider(options, project) {
  if (options.provider == null || builtinProviders.includes(options.provider)) {
    const providers = await import('./providers.js');
    const provider = options.provider || "preview";
    return providers[provider];
  }
  let customProviderModule;
  try {
    customProviderModule = await project.runner.executeId(
      options.provider
    );
  } catch (error) {
    throw new Error(
      `Failed to load custom BrowserProvider from ${options.provider}`,
      { cause: error }
    );
  }
  if (customProviderModule.default == null) {
    throw new Error(
      `Custom BrowserProvider loaded from ${options.provider} was not the default export`
    );
  }
  return customProviderModule.default;
}

class BrowserServerCDPHandler {
  constructor(session, tester) {
    this.session = session;
    this.tester = tester;
  }
  listenerIds = {};
  listeners = {};
  send(method, params) {
    return this.session.send(method, params);
  }
  on(event, id, once = false) {
    if (!this.listenerIds[event]) {
      this.listenerIds[event] = [];
    }
    this.listenerIds[event].push(id);
    if (!this.listeners[event]) {
      this.listeners[event] = (payload) => {
        this.tester.cdpEvent(
          event,
          payload
        );
        if (once) {
          this.off(event, id);
        }
      };
      this.session.on(event, this.listeners[event]);
    }
  }
  off(event, id) {
    if (!this.listenerIds[event]) {
      this.listenerIds[event] = [];
    }
    this.listenerIds[event] = this.listenerIds[event].filter((l) => l !== id);
    if (!this.listenerIds[event].length) {
      this.session.off(event, this.listeners[event]);
      delete this.listeners[event];
    }
  }
  once(event, listener) {
    this.on(event, listener, true);
  }
}

class BrowserServer {
  constructor(project, base) {
    this.project = project;
    this.base = base;
    this.stackTraceOptions = {
      frameFilter: project.config.onStackTrace,
      getSourceMap: (id) => {
        const result = this.vite.moduleGraph.getModuleById(id)?.transformResult;
        return result?.map;
      },
      getFileName: (id) => {
        const mod = this.vite.moduleGraph.getModuleById(id);
        if (mod?.file) {
          return mod.file;
        }
        const modUrl = this.vite.moduleGraph.urlToModuleMap.get(id);
        if (modUrl?.file) {
          return modUrl.file;
        }
        return id;
      }
    };
    this.state = new BrowserServerState();
    const pkgRoot = resolve(fileURLToPath(import.meta.url), "../..");
    const distRoot = resolve(pkgRoot, "dist");
    this.prefixTesterUrl = `${base}__vitest_test__/__test__/`;
    this.faviconUrl = `${base}__vitest__/favicon.svg`;
    this.manifest = (async () => {
      return JSON.parse(
        await readFile$1(`${distRoot}/client/.vite/manifest.json`, "utf8")
      );
    })().then((manifest) => this.manifest = manifest);
    this.testerHtml = readFile$1(
      resolve(distRoot, "client/tester/tester.html"),
      "utf8"
    ).then((html) => this.testerHtml = html);
    this.orchestratorHtml = (project.config.browser.ui ? readFile$1(resolve(distRoot, "client/__vitest__/index.html"), "utf8") : readFile$1(resolve(distRoot, "client/orchestrator.html"), "utf8")).then((html) => this.orchestratorHtml = html);
    this.injectorJs = readFile$1(
      resolve(distRoot, "client/esm-client-injector.js"),
      "utf8"
    ).then((js) => this.injectorJs = js);
    this.errorCatcherPath = resolve(distRoot, "client/error-catcher.js");
    this.stateJs = readFile$1(
      resolve(distRoot, "state.js"),
      "utf-8"
    ).then((js) => this.stateJs = js);
  }
  faviconUrl;
  prefixTesterUrl;
  orchestratorScripts;
  testerScripts;
  manifest;
  testerHtml;
  orchestratorHtml;
  injectorJs;
  errorCatcherPath;
  stateJs;
  state;
  provider;
  vite;
  stackTraceOptions;
  setServer(server) {
    this.vite = server;
  }
  getSerializableConfig() {
    const config = wrapConfig(this.project.getSerializableConfig());
    config.env ??= {};
    config.env.VITEST_BROWSER_DEBUG = process.env.VITEST_BROWSER_DEBUG || "";
    return config;
  }
  resolveTesterUrl(pathname) {
    const [contextId, testFile] = pathname.slice(this.prefixTesterUrl.length).split("/");
    const decodedTestFile = decodeURIComponent(testFile);
    return { contextId, testFile: decodedTestFile };
  }
  async formatScripts(scripts) {
    if (!scripts?.length) {
      return "";
    }
    const server = this.vite;
    const promises = scripts.map(
      async ({ content, src, async, id, type = "module" }, index) => {
        const srcLink = (src ? (await server.pluginContainer.resolveId(src))?.id : void 0) || src;
        const transformId = srcLink || join(server.config.root, `virtual__${id || `injected-${index}.js`}`);
        await server.moduleGraph.ensureEntryFromUrl(transformId);
        const contentProcessed = content && type === "module" ? (await server.pluginContainer.transform(content, transformId)).code : content;
        return `<script type="${type}"${async ? " async" : ""}${srcLink ? ` src="${slash(`/@fs/${srcLink}`)}"` : ""}>${contentProcessed || ""}<\/script>`;
      }
    );
    return (await Promise.all(promises)).join("\n");
  }
  async initBrowserProvider() {
    if (this.provider) {
      return;
    }
    const Provider = await getBrowserProvider(this.project.config.browser, this.project);
    this.provider = new Provider();
    const browser = this.project.config.browser.name;
    if (!browser) {
      throw new Error(
        `[${this.project.getName()}] Browser name is required. Please, set \`test.browser.name\` option manually.`
      );
    }
    const supportedBrowsers = this.provider.getSupportedBrowsers();
    if (supportedBrowsers.length && !supportedBrowsers.includes(browser)) {
      throw new Error(
        `[${this.project.getName()}] Browser "${browser}" is not supported by the browser provider "${this.provider.name}". Supported browsers: ${supportedBrowsers.join(", ")}.`
      );
    }
    const providerOptions = this.project.config.browser.providerOptions;
    await this.provider.initialize(this.project, {
      browser,
      options: providerOptions
    });
  }
  parseErrorStacktrace(e, options = {}) {
    return parseErrorStacktrace(e, {
      ...this.stackTraceOptions,
      ...options
    });
  }
  parseStacktrace(trace, options = {}) {
    return parseStacktrace(trace, {
      ...this.stackTraceOptions,
      ...options
    });
  }
  cdpSessionsPromises = /* @__PURE__ */ new Map();
  async ensureCDPHandler(contextId, sessionId) {
    const cachedHandler = this.state.cdps.get(sessionId);
    if (cachedHandler) {
      return cachedHandler;
    }
    const provider = this.provider;
    if (!provider.getCDPSession) {
      throw new Error(`CDP is not supported by the provider "${provider.name}".`);
    }
    const promise = this.cdpSessionsPromises.get(sessionId) ?? await (async () => {
      const promise2 = provider.getCDPSession(contextId).finally(() => {
        this.cdpSessionsPromises.delete(sessionId);
      });
      this.cdpSessionsPromises.set(sessionId, promise2);
      return promise2;
    })();
    const session = await promise;
    const rpc = this.state.testers.get(sessionId);
    if (!rpc) {
      throw new Error(`Tester RPC "${sessionId}" was not established.`);
    }
    const handler = new BrowserServerCDPHandler(session, rpc);
    this.state.cdps.set(
      sessionId,
      handler
    );
    return handler;
  }
  async close() {
    await this.vite.close();
  }
}
function wrapConfig(config) {
  return {
    ...config,
    // workaround RegExp serialization
    testNamePattern: config.testNamePattern ? config.testNamePattern.toString() : void 0
  };
}

const click = async (context, selector, options = {}) => {
  const provider = context.provider;
  if (provider instanceof PlaywrightBrowserProvider) {
    const tester = context.iframe;
    await tester.locator(`css=${selector}`).click({
      timeout: 1e3,
      ...options
    });
  } else if (provider instanceof WebdriverBrowserProvider) {
    const browser = context.browser;
    await browser.$(selector).click(options);
  } else {
    throw new TypeError(`Provider "${provider.name}" doesn't support click command`);
  }
};
const dblClick = async (context, selector, options = {}) => {
  const provider = context.provider;
  if (provider instanceof PlaywrightBrowserProvider) {
    const tester = context.iframe;
    await tester.locator(`css=${selector}`).dblclick(options);
  } else if (provider instanceof WebdriverBrowserProvider) {
    const browser = context.browser;
    await browser.$(selector).doubleClick();
  } else {
    throw new TypeError(`Provider "${provider.name}" doesn't support dblClick command`);
  }
};
const tripleClick = async (context, selector, options = {}) => {
  const provider = context.provider;
  if (provider instanceof PlaywrightBrowserProvider) {
    const tester = context.iframe;
    await tester.locator(`css=${selector}`).click({
      timeout: 1e3,
      ...options,
      clickCount: 3
    });
  } else if (provider instanceof WebdriverBrowserProvider) {
    const browser = context.browser;
    await browser.action("pointer", { parameters: { pointerType: "mouse" } }).move({ origin: await browser.$(selector) }).down().up().pause(50).down().up().pause(50).down().up().pause(50).perform();
  } else {
    throw new TypeError(`Provider "${provider.name}" doesn't support tripleClick command`);
  }
};

var clickableInputTypes;
(function(clickableInputTypes) {
    clickableInputTypes["button"] = "button";
    clickableInputTypes["color"] = "color";
    clickableInputTypes["file"] = "file";
    clickableInputTypes["image"] = "image";
    clickableInputTypes["reset"] = "reset";
    clickableInputTypes["submit"] = "submit";
    clickableInputTypes["checkbox"] = "checkbox";
    clickableInputTypes["radio"] = "radio";
})(clickableInputTypes || (clickableInputTypes = {}));

var editableInputTypes;
(function(editableInputTypes) {
    editableInputTypes["text"] = "text";
    editableInputTypes["date"] = "date";
    editableInputTypes["datetime-local"] = "datetime-local";
    editableInputTypes["email"] = "email";
    editableInputTypes["month"] = "month";
    editableInputTypes["number"] = "number";
    editableInputTypes["password"] = "password";
    editableInputTypes["search"] = "search";
    editableInputTypes["tel"] = "tel";
    editableInputTypes["time"] = "time";
    editableInputTypes["url"] = "url";
    editableInputTypes["week"] = "week";
})(editableInputTypes || (editableInputTypes = {}));

var maxLengthSupportedTypes;
(function(maxLengthSupportedTypes) {
    maxLengthSupportedTypes["email"] = "email";
    maxLengthSupportedTypes["password"] = "password";
    maxLengthSupportedTypes["search"] = "search";
    maxLengthSupportedTypes["telephone"] = "telephone";
    maxLengthSupportedTypes["text"] = "text";
    maxLengthSupportedTypes["url"] = "url";
})(maxLengthSupportedTypes || (maxLengthSupportedTypes = {}));

var bracketDict;
(function(bracketDict) {
    bracketDict["{"] = "}";
    bracketDict["["] = "]";
})(bracketDict || (bracketDict = {}));
/**
 * Read the next key definition from user input
 *
 * Describe key per `{descriptor}` or `[descriptor]`.
 * Everything else will be interpreted as a single character as descriptor - e.g. `a`.
 * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.
 * A previously pressed key can be released per `{/descriptor}`.
 * Keeping the key pressed can be written as `{descriptor>}`.
 * When keeping the key pressed you can choose how long the key is pressed `{descriptor>3}`.
 * You can then release the key per `{descriptor>3/}` or keep it pressed and continue with the next key.
 */ function readNextDescriptor(text, context) {
    let pos = 0;
    const startBracket = text[pos] in bracketDict ? text[pos] : '';
    pos += startBracket.length;
    const isEscapedChar = new RegExp(`^\\${startBracket}{2}`).test(text);
    const type = isEscapedChar ? '' : startBracket;
    return {
        type,
        ...type === '' ? readPrintableChar(text, pos) : readTag(text, pos, type)
    };
}
function readPrintableChar(text, pos, context) {
    const descriptor = text[pos];
    assertDescriptor(descriptor, text, pos);
    pos += descriptor.length;
    return {
        consumedLength: pos,
        descriptor,
        releasePrevious: false,
        releaseSelf: true,
        repeat: 1
    };
}
function readTag(text, pos, startBracket, context) {
    var _text_slice_match, _text_slice_match1;
    const releasePreviousModifier = text[pos] === '/' ? '/' : '';
    pos += releasePreviousModifier.length;
    const escapedDescriptor = startBracket === '{' && text[pos] === '\\';
    pos += Number(escapedDescriptor);
    const descriptor = escapedDescriptor ? text[pos] : (_text_slice_match = text.slice(pos).match(startBracket === '{' ? /^\w+|^[^}>/]/ : /^\w+/)) === null || _text_slice_match === void 0 ? void 0 : _text_slice_match[0];
    assertDescriptor(descriptor, text, pos);
    pos += descriptor.length;
    var _text_slice_match_;
    const repeatModifier = (_text_slice_match_ = (_text_slice_match1 = text.slice(pos).match(/^>\d+/)) === null || _text_slice_match1 === void 0 ? void 0 : _text_slice_match1[0]) !== null && _text_slice_match_ !== void 0 ? _text_slice_match_ : '';
    pos += repeatModifier.length;
    const releaseSelfModifier = text[pos] === '/' || !repeatModifier && text[pos] === '>' ? text[pos] : '';
    pos += releaseSelfModifier.length;
    const expectedEndBracket = bracketDict[startBracket];
    const endBracket = text[pos] === expectedEndBracket ? expectedEndBracket : '';
    if (!endBracket) {
        throw new Error(getErrorMessage([
            !repeatModifier && 'repeat modifier',
            !releaseSelfModifier && 'release modifier',
            `"${expectedEndBracket}"`
        ].filter(Boolean).join(' or '), text[pos], text));
    }
    pos += endBracket.length;
    return {
        consumedLength: pos,
        descriptor,
        releasePrevious: !!releasePreviousModifier,
        repeat: repeatModifier ? Math.max(Number(repeatModifier.substr(1)), 1) : 1,
        releaseSelf: hasReleaseSelf(releaseSelfModifier, repeatModifier)
    };
}
function assertDescriptor(descriptor, text, pos, context) {
    if (!descriptor) {
        throw new Error(getErrorMessage('key descriptor', text[pos], text));
    }
}
function hasReleaseSelf(releaseSelfModifier, repeatModifier) {
    if (releaseSelfModifier) {
        return releaseSelfModifier === '/';
    }
    if (repeatModifier) {
        return false;
    }
}
function getErrorMessage(expected, found, text, context) {
    return `Expected ${expected} but found "${found !== null && found !== void 0 ? found : ''}" in "${text}"
    See ${`https://testing-library.com/docs/user-event/keyboard`}
    for more information about how userEvent parses your input.`;
}

var ApiLevel;
(function(ApiLevel) {
    ApiLevel[ApiLevel["Trigger"] = 2] = "Trigger";
    ApiLevel[ApiLevel["Call"] = 1] = "Call";
})(ApiLevel || (ApiLevel = {}));

var PointerEventsCheckLevel;
(function(PointerEventsCheckLevel) {
    /**
   * Check pointer events on every user interaction that triggers a bunch of events.
   * E.g. once for releasing a mouse button even though this triggers `pointerup`, `mouseup`, `click`, etc...
   */ PointerEventsCheckLevel[PointerEventsCheckLevel["EachTrigger"] = 4] = "EachTrigger";
    /** Check each target once per call to pointer (related) API */ PointerEventsCheckLevel[PointerEventsCheckLevel["EachApiCall"] = 2] = "EachApiCall";
    /** Check each event target once */ PointerEventsCheckLevel[PointerEventsCheckLevel["EachTarget"] = 1] = "EachTarget";
    /** No pointer events check */ PointerEventsCheckLevel[PointerEventsCheckLevel["Never"] = 0] = "Never";
})(PointerEventsCheckLevel || (PointerEventsCheckLevel = {}));

/**
 * Parse key defintions per `keyboardMap`
 *
 * Keys can be referenced by `{key}` or `{special}` as well as physical locations per `[code]`.
 * Everything else will be interpreted as a typed character - e.g. `a`.
 * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.
 * Keeping the key pressed can be written as `{key>}`.
 * When keeping the key pressed you can choose how long (how many keydown and keypress) the key is pressed `{key>3}`.
 * You can then release the key per `{key>3/}` or keep it pressed and continue with the next key.
 */ function parseKeyDef(keyboardMap, text) {
    const defs = [];
    do {
        const { type, descriptor, consumedLength, releasePrevious, releaseSelf = true, repeat } = readNextDescriptor(text);
        var _keyboardMap_find;
        const keyDef = (_keyboardMap_find = keyboardMap.find((def)=>{
            if (type === '[') {
                var _def_code;
                return ((_def_code = def.code) === null || _def_code === void 0 ? void 0 : _def_code.toLowerCase()) === descriptor.toLowerCase();
            } else if (type === '{') {
                var _def_key;
                return ((_def_key = def.key) === null || _def_key === void 0 ? void 0 : _def_key.toLowerCase()) === descriptor.toLowerCase();
            }
            return def.key === descriptor;
        })) !== null && _keyboardMap_find !== void 0 ? _keyboardMap_find : {
            key: 'Unknown',
            code: 'Unknown',
            [type === '[' ? 'code' : 'key']: descriptor
        };
        defs.push({
            keyDef,
            releasePrevious,
            releaseSelf,
            repeat
        });
        text = text.slice(consumedLength);
    }while (text)
    return defs;
}

var DOM_KEY_LOCATION;
(function(DOM_KEY_LOCATION) {
    DOM_KEY_LOCATION[DOM_KEY_LOCATION["STANDARD"] = 0] = "STANDARD";
    DOM_KEY_LOCATION[DOM_KEY_LOCATION["LEFT"] = 1] = "LEFT";
    DOM_KEY_LOCATION[DOM_KEY_LOCATION["RIGHT"] = 2] = "RIGHT";
    DOM_KEY_LOCATION[DOM_KEY_LOCATION["NUMPAD"] = 3] = "NUMPAD";
})(DOM_KEY_LOCATION || (DOM_KEY_LOCATION = {}));

/**
 * Mapping for a default US-104-QWERTY keyboard
 */ const defaultKeyMap = [
    // alphanumeric keys
    ...'0123456789'.split('').map((c)=>({
            code: `Digit${c}`,
            key: c
        })),
    ...')!@#$%^&*('.split('').map((c, i)=>({
            code: `Digit${i}`,
            key: c,
            shiftKey: true
        })),
    ...'abcdefghijklmnopqrstuvwxyz'.split('').map((c)=>({
            code: `Key${c.toUpperCase()}`,
            key: c
        })),
    ...'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('').map((c)=>({
            code: `Key${c}`,
            key: c,
            shiftKey: true
        })),
    // alphanumeric block - functional
    {
        code: 'Space',
        key: ' '
    },
    {
        code: 'AltLeft',
        key: 'Alt',
        location: DOM_KEY_LOCATION.LEFT
    },
    {
        code: 'AltRight',
        key: 'Alt',
        location: DOM_KEY_LOCATION.RIGHT
    },
    {
        code: 'ShiftLeft',
        key: 'Shift',
        location: DOM_KEY_LOCATION.LEFT
    },
    {
        code: 'ShiftRight',
        key: 'Shift',
        location: DOM_KEY_LOCATION.RIGHT
    },
    {
        code: 'ControlLeft',
        key: 'Control',
        location: DOM_KEY_LOCATION.LEFT
    },
    {
        code: 'ControlRight',
        key: 'Control',
        location: DOM_KEY_LOCATION.RIGHT
    },
    {
        code: 'MetaLeft',
        key: 'Meta',
        location: DOM_KEY_LOCATION.LEFT
    },
    {
        code: 'MetaRight',
        key: 'Meta',
        location: DOM_KEY_LOCATION.RIGHT
    },
    {
        code: 'OSLeft',
        key: 'OS',
        location: DOM_KEY_LOCATION.LEFT
    },
    {
        code: 'OSRight',
        key: 'OS',
        location: DOM_KEY_LOCATION.RIGHT
    },
    {
        code: 'Tab',
        key: 'Tab'
    },
    {
        code: 'CapsLock',
        key: 'CapsLock'
    },
    {
        code: 'Backspace',
        key: 'Backspace'
    },
    {
        code: 'Enter',
        key: 'Enter'
    },
    // function
    {
        code: 'Escape',
        key: 'Escape'
    },
    // arrows
    {
        code: 'ArrowUp',
        key: 'ArrowUp'
    },
    {
        code: 'ArrowDown',
        key: 'ArrowDown'
    },
    {
        code: 'ArrowLeft',
        key: 'ArrowLeft'
    },
    {
        code: 'ArrowRight',
        key: 'ArrowRight'
    },
    // control pad
    {
        code: 'Home',
        key: 'Home'
    },
    {
        code: 'End',
        key: 'End'
    },
    {
        code: 'Delete',
        key: 'Delete'
    },
    {
        code: 'PageUp',
        key: 'PageUp'
    },
    {
        code: 'PageDown',
        key: 'PageDown'
    },
    // Special keys that are not part of a default US-layout but included for specific behavior
    {
        code: 'Fn',
        key: 'Fn'
    },
    {
        code: 'Symbol',
        key: 'Symbol'
    },
    {
        code: 'AltRight',
        key: 'AltGraph'
    }
];

const keyboard = async (context, text, state) => {
  function focusIframe() {
    if (!document.activeElement || document.activeElement.ownerDocument !== document || document.activeElement === document.body) {
      window.focus();
    }
  }
  if (context.provider instanceof PlaywrightBrowserProvider) {
    const frame = await context.frame();
    await frame.evaluate(focusIframe);
  } else if (context.provider instanceof WebdriverBrowserProvider) {
    await context.browser.execute(focusIframe);
  }
  const pressed = new Set(state.unreleased);
  await keyboardImplementation(
    pressed,
    context.provider,
    context.contextId,
    text,
    async () => {
      function selectAll() {
        const element = document.activeElement;
        if (element && element.select) {
          element.select();
        }
      }
      if (context.provider instanceof PlaywrightBrowserProvider) {
        const frame = await context.frame();
        await frame.evaluate(selectAll);
      } else if (context.provider instanceof WebdriverBrowserProvider) {
        await context.browser.execute(selectAll);
      } else {
        throw new TypeError(`Provider "${context.provider.name}" does not support selecting all text`);
      }
    },
    true
  );
  return {
    unreleased: Array.from(pressed)
  };
};
async function keyboardImplementation(pressed, provider, contextId, text, selectAll, skipRelease) {
  if (provider instanceof PlaywrightBrowserProvider) {
    const page = provider.getPage(contextId);
    const actions = parseKeyDef(defaultKeyMap, text);
    for (const { releasePrevious, releaseSelf, repeat, keyDef } of actions) {
      const key = keyDef.key;
      if (pressed.has(key)) {
        await page.keyboard.up(key);
        pressed.delete(key);
      }
      if (!releasePrevious) {
        if (key === "selectall") {
          await selectAll();
          continue;
        }
        for (let i = 1; i <= repeat; i++) {
          await page.keyboard.down(key);
        }
        if (releaseSelf) {
          await page.keyboard.up(key);
        } else {
          pressed.add(key);
        }
      }
    }
    if (!skipRelease && pressed.size) {
      for (const key of pressed) {
        await page.keyboard.up(key);
      }
    }
  } else if (provider instanceof WebdriverBrowserProvider) {
    const { Key } = await import('webdriverio');
    const browser = provider.browser;
    const actions = parseKeyDef(defaultKeyMap, text);
    let keyboard2 = browser.action("key");
    for (const { releasePrevious, releaseSelf, repeat, keyDef } of actions) {
      let key = keyDef.key;
      const code = "location" in keyDef ? keyDef.key : keyDef.code;
      const special = Key[code];
      if (special) {
        key = special;
      }
      if (pressed.has(key)) {
        keyboard2.up(key);
        pressed.delete(key);
      }
      if (!releasePrevious) {
        if (key === "selectall") {
          await keyboard2.perform();
          keyboard2 = browser.action("key");
          await selectAll();
          continue;
        }
        for (let i = 1; i <= repeat; i++) {
          keyboard2.down(key);
        }
        if (releaseSelf) {
          keyboard2.up(key);
        } else {
          pressed.add(key);
        }
      }
    }
    const allRelease = keyboard2.toJSON().actions.every((action) => action.type === "keyUp");
    await keyboard2.perform(allRelease ? false : skipRelease);
  }
  return {
    pressed
  };
}

const type = async (context, selector, text, options = {}) => {
  const { skipClick = false, skipAutoClose = false } = options;
  const unreleased = new Set(Reflect.get(options, "unreleased") ?? []);
  if (context.provider instanceof PlaywrightBrowserProvider) {
    const { iframe } = context;
    const element = iframe.locator(`css=${selector}`);
    if (!skipClick) {
      await element.focus();
    }
    await keyboardImplementation(
      unreleased,
      context.provider,
      context.contextId,
      text,
      () => element.selectText(),
      skipAutoClose
    );
  } else if (context.provider instanceof WebdriverBrowserProvider) {
    const browser = context.browser;
    const element = browser.$(selector);
    if (!skipClick && !await element.isFocused()) {
      await element.click();
    }
    await keyboardImplementation(
      unreleased,
      context.provider,
      context.contextId,
      text,
      () => browser.execute(() => {
        const element2 = document.activeElement;
        if (element2) {
          element2.select();
        }
      }),
      skipAutoClose
    );
  } else {
    throw new TypeError(`Provider "${context.provider.name}" does not support typing`);
  }
  return {
    unreleased: Array.from(unreleased)
  };
};

const clear = async (context, selector) => {
  if (context.provider instanceof PlaywrightBrowserProvider) {
    const { iframe } = context;
    const element = iframe.locator(`css=${selector}`);
    await element.clear({
      timeout: 1e3
    });
  } else if (context.provider instanceof WebdriverBrowserProvider) {
    const browser = context.browser;
    const element = await browser.$(selector);
    await element.clearValue();
  } else {
    throw new TypeError(`Provider "${context.provider.name}" does not support clearing elements`);
  }
};

const fill = async (context, selector, text, options = {}) => {
  if (context.provider instanceof PlaywrightBrowserProvider) {
    const { iframe } = context;
    const element = iframe.locator(`css=${selector}`);
    await element.fill(text, { timeout: 1e3, ...options });
  } else if (context.provider instanceof WebdriverBrowserProvider) {
    const browser = context.browser;
    await browser.$(selector).setValue(text);
  } else {
    throw new TypeError(`Provider "${context.provider.name}" does not support clearing elements`);
  }
};

const selectOptions = async (context, selector, userValues, options = {}) => {
  if (context.provider instanceof PlaywrightBrowserProvider) {
    const value = userValues;
    const { iframe } = context;
    const selectElement = iframe.locator(`css=${selector}`);
    const values = await Promise.all(value.map(async (v) => {
      if (typeof v === "string") {
        return v;
      }
      const elementHandler = await iframe.locator(`css=${v.element}`).elementHandle();
      if (!elementHandler) {
        throw new Error(`Element not found: ${v.element}`);
      }
      return elementHandler;
    }));
    await selectElement.selectOption(values, {
      timeout: 1e3,
      ...options
    });
  } else if (context.provider instanceof WebdriverBrowserProvider) {
    const values = userValues;
    if (!values.length) {
      return;
    }
    const browser = context.browser;
    if (values.length === 1 && "index" in values[0]) {
      const selectElement = browser.$(selector);
      await selectElement.selectByIndex(values[0].index);
    } else {
      throw new Error(`Provider "webdriverio" doesn't support selecting multiple values at once`);
    }
  } else {
    throw new TypeError(`Provider "${context.provider.name}" doesn't support selectOptions command`);
  }
};

const tab = async (context, options = {}) => {
  const provider = context.provider;
  if (provider instanceof PlaywrightBrowserProvider) {
    const page = context.page;
    await page.keyboard.press(options.shift === true ? "Shift+Tab" : "Tab");
    return;
  }
  if (provider instanceof WebdriverBrowserProvider) {
    const { Key } = await import('webdriverio');
    const browser = context.browser;
    await browser.keys(options.shift === true ? [Key.Shift, Key.Tab] : [Key.Tab]);
    return;
  }
  throw new Error(`Provider "${provider.name}" doesn't support tab command`);
};

const dragAndDrop = async (context, source, target, options) => {
  if (context.provider instanceof PlaywrightBrowserProvider) {
    const frame = await context.frame();
    await frame.dragAndDrop(
      `css=${source}`,
      `css=${target}`,
      {
        timeout: 1e3,
        ...options
      }
    );
  } else if (context.provider instanceof WebdriverBrowserProvider) {
    const $source = context.browser.$(source);
    const $target = context.browser.$(target);
    const duration = options?.duration ?? 10;
    await context.browser.action("pointer").move({ duration: 0, origin: $source, x: 0, y: 0 }).down({ button: 0 }).move({ duration: 0, origin: "pointer", x: 0, y: 0 }).pause(duration).move({ duration: 0, origin: $target, x: 0, y: 0 }).move({ duration: 0, origin: "pointer", x: 1, y: 0 }).move({ duration: 0, origin: "pointer", x: -1, y: 0 }).up({ button: 0 }).perform();
  } else {
    throw new TypeError(`Provider "${context.provider.name}" does not support dragging elements`);
  }
};

const hover = async (context, selector, options = {}) => {
  if (context.provider instanceof PlaywrightBrowserProvider) {
    await context.iframe.locator(`css=${selector}`).hover({
      timeout: 1e3,
      ...options
    });
  } else if (context.provider instanceof WebdriverBrowserProvider) {
    const browser = context.browser;
    await browser.$(selector).moveTo(options);
  } else {
    throw new TypeError(`Provider "${context.provider.name}" does not support hover`);
  }
};

function assertFileAccess(path, project) {
  if (!isFileServingAllowed(path, project.server) && !isFileServingAllowed(path, project.ctx.server)) {
    throw new Error(
      `Access denied to "${path}". See Vite config documentation for "server.fs": https://vitejs.dev/config/server-options.html#server-fs-strict.`
    );
  }
}
const readFile = async ({ project, testPath = process.cwd() }, path, options = {}) => {
  const filepath = resolve$1(dirname$1(testPath), path);
  assertFileAccess(filepath, project);
  if (typeof options === "object" && !options.encoding) {
    options.encoding = "utf-8";
  }
  return promises.readFile(filepath, options);
};
const writeFile = async ({ project, testPath = process.cwd() }, path, data, options) => {
  const filepath = resolve$1(dirname$1(testPath), path);
  assertFileAccess(filepath, project);
  const dir = dirname$1(filepath);
  if (!fs.existsSync(dir)) {
    await promises.mkdir(dir, { recursive: true });
  }
  await promises.writeFile(filepath, data, options);
};
const removeFile = async ({ project, testPath = process.cwd() }, path) => {
  const filepath = resolve$1(dirname$1(testPath), path);
  assertFileAccess(filepath, project);
  await promises.rm(filepath);
};

const screenshot = async (context, name, options = {}) => {
  if (!context.testPath) {
    throw new Error(`Cannot take a screenshot without a test path`);
  }
  const path = resolveScreenshotPath(
    context.testPath,
    name,
    context.project.config
  );
  const savePath = normalize$1(path);
  await mkdir(dirname(path), { recursive: true });
  if (context.provider instanceof PlaywrightBrowserProvider) {
    if (options.element) {
      const { element: css, ...config } = options;
      const element = context.iframe.locator(`css=${css}`);
      const buffer2 = await element.screenshot({
        timeout: 1e3,
        ...config,
        path: savePath
      });
      return returnResult(options, path, buffer2);
    }
    const buffer = await context.iframe.locator("body").screenshot({
      ...options,
      path: savePath
    });
    return returnResult(options, path, buffer);
  }
  if (context.provider instanceof WebdriverBrowserProvider) {
    const page = context.provider.browser;
    if (!options.element) {
      const body = await page.$("body");
      const buffer2 = await body.saveScreenshot(savePath);
      return returnResult(options, path, buffer2);
    }
    const element = await page.$(`${options.element}`);
    const buffer = await element.saveScreenshot(savePath);
    return returnResult(options, path, buffer);
  }
  throw new Error(
    `Provider "${context.provider.name}" does not support screenshots`
  );
};
function resolveScreenshotPath(testPath, name, config) {
  const dir = dirname(testPath);
  const base = basename(testPath);
  if (config.browser.screenshotDirectory) {
    return resolve(
      config.browser.screenshotDirectory,
      relative(config.root, dir),
      base,
      name
    );
  }
  return resolve(dir, "__screenshots__", base, name);
}
function returnResult(options, path, buffer) {
  if (options.base64) {
    return { path, base64: buffer.toString("base64") };
  }
  return path;
}

var builtinCommands = {
  readFile,
  removeFile,
  writeFile,
  __vitest_click: click,
  __vitest_dblClick: dblClick,
  __vitest_tripleClick: tripleClick,
  __vitest_screenshot: screenshot,
  __vitest_type: type,
  __vitest_clear: clear,
  __vitest_fill: fill,
  __vitest_tab: tab,
  __vitest_keyboard: keyboard,
  __vitest_selectOptions: selectOptions,
  __vitest_dragAndDrop: dragAndDrop,
  __vitest_hover: hover
};

const VIRTUAL_ID_CONTEXT = "\0@vitest/browser/context";
const ID_CONTEXT = "@vitest/browser/context";
const __dirname = dirname(fileURLToPath(import.meta.url));
function BrowserContext(server) {
  const project = server.project;
  project.config.browser.commands ??= {};
  for (const [name, command] of Object.entries(builtinCommands)) {
    project.config.browser.commands[name] ??= command;
  }
  for (const command in project.config.browser.commands) {
    if (!/^[a-z_$][\w$]*$/i.test(command)) {
      throw new Error(
        `Invalid command name "${command}". Only alphanumeric characters, $ and _ are allowed.`
      );
    }
  }
  return {
    name: "vitest:browser:virtual-module:context",
    enforce: "pre",
    resolveId(id) {
      if (id === ID_CONTEXT) {
        return VIRTUAL_ID_CONTEXT;
      }
    },
    load(id) {
      if (id === VIRTUAL_ID_CONTEXT) {
        return generateContextFile.call(this, server);
      }
    }
  };
}
async function generateContextFile(server) {
  const commands = Object.keys(server.project.config.browser.commands ?? {});
  const filepathCode = "__vitest_worker__.filepath || __vitest_worker__.current?.file?.filepath || undefined";
  const provider = server.provider;
  const commandsCode = commands.filter((command) => !command.startsWith("__vitest")).map((command) => {
    return `    ["${command}"]: (...args) => rpc().triggerCommand(contextId, "${command}", filepath(), args),`;
  }).join("\n");
  const userEventNonProviderImport = await getUserEventImport(
    provider,
    this.resolve.bind(this)
  );
  const distContextPath = slash(`/@fs/${resolve(__dirname, "context.js")}`);
  return `
import { page, userEvent as __userEvent_CDP__, cdp } from '${distContextPath}'
${userEventNonProviderImport}
const filepath = () => ${filepathCode}
const rpc = () => __vitest_worker__.rpc
const contextId = __vitest_browser_runner__.contextId

export const server = {
  platform: ${JSON.stringify(process.platform)},
  version: ${JSON.stringify(process.version)},
  provider: ${JSON.stringify(provider.name)},
  browser: ${JSON.stringify(server.project.config.browser.name)},
  commands: {
    ${commandsCode}
  }
}
export const commands = server.commands
export const userEvent = ${getUserEvent(provider)}
export { page, cdp }
`;
}
function getUserEvent(provider) {
  if (provider.name !== "preview") {
    return "__userEvent_CDP__";
  }
  return `{
  ..._userEventSetup,
  setup() {
    const userEvent = __vitest_user_event__.setup()
    userEvent.setup = this.setup
    userEvent.fill = this.fill.bind(userEvent)
    userEvent.dragAndDrop = this.dragAndDrop
    return userEvent
  },
  async fill(element, text) {
    await this.clear(element)
    await this.type(element, text)
  },
  dragAndDrop: async () => {
    throw new Error('Provider "preview" does not support dragging elements')
  }
}`;
}
async function getUserEventImport(provider, resolve2) {
  if (provider.name !== "preview") {
    return "";
  }
  const resolved = await resolve2("@testing-library/user-event", __dirname);
  if (!resolved) {
    throw new Error(`Failed to resolve user-event package from ${__dirname}`);
  }
  return `import { userEvent as __vitest_user_event__ } from '${slash(
    `/@fs/${resolved.id}`
  )}'
const _userEventSetup = __vitest_user_event__.setup()
`;
}

function injectDynamicImport(code, id, parse) {
  const s = new MagicString(code);
  let ast;
  try {
    ast = parse(code);
  } catch (err) {
    console.error(`Cannot parse ${id}:
${err.message}`);
    return;
  }
  esmWalker(ast, {
    // TODO: make env updatable
    onImportMeta() {
    },
    onDynamicImport(node) {
      const replaceString = "__vitest_browser_runner__.wrapModule(() => import(";
      const importSubstring = code.substring(node.start, node.end);
      const hasIgnore = importSubstring.includes("/* @vite-ignore */");
      s.overwrite(
        node.start,
        node.source.start,
        replaceString + (hasIgnore ? "/* @vite-ignore */ " : "")
      );
      s.overwrite(node.end - 1, node.end, "))");
    }
  });
  return {
    ast,
    code: s.toString(),
    map: s.generateMap({ hires: "boundary", source: id })
  };
}

const regexDynamicImport = /import\s*\(/;
var DynamicImport = () => {
  return {
    name: "vitest:browser:esm-injector",
    enforce: "post",
    transform(source, id) {
      if (!regexDynamicImport.test(source)) {
        return;
      }
      return injectDynamicImport(source, id, this.parse);
    }
  };
};

async function resolveOrchestrator(server, url, res) {
  const project = server.project;
  let contextId = url.searchParams.get("contextId");
  if (!contextId) {
    const contexts = [...server.state.orchestrators.keys()];
    contextId = contexts[contexts.length - 1] ?? "none";
  }
  const files = server.state.getContext(contextId)?.files ?? [];
  const injectorJs = typeof server.injectorJs === "string" ? server.injectorJs : await server.injectorJs;
  const injector = replacer(injectorJs, {
    __VITEST_PROVIDER__: JSON.stringify(server.provider.name),
    __VITEST_CONFIG__: JSON.stringify(server.getSerializableConfig()),
    __VITEST_VITE_CONFIG__: JSON.stringify({
      root: server.vite.config.root
    }),
    __VITEST_FILES__: JSON.stringify(files),
    __VITEST_TYPE__: '"orchestrator"',
    __VITEST_CONTEXT_ID__: JSON.stringify(contextId),
    __VITEST_TESTER_ID__: '"none"',
    __VITEST_PROVIDED_CONTEXT__: "{}"
  });
  res.removeHeader("Content-Security-Policy");
  if (!server.orchestratorScripts) {
    server.orchestratorScripts = await server.formatScripts(
      project.config.browser.orchestratorScripts
    );
  }
  let baseHtml = typeof server.orchestratorHtml === "string" ? server.orchestratorHtml : await server.orchestratorHtml;
  if (project.config.browser.ui) {
    const manifestContent = server.manifest instanceof Promise ? await server.manifest : server.manifest;
    const jsEntry = manifestContent["orchestrator.html"].file;
    const base = server.vite.config.base || "/";
    baseHtml = baseHtml.replaceAll("./assets/", `${base}__vitest__/assets/`).replace(
      "<!-- !LOAD_METADATA! -->",
      [
        "{__VITEST_INJECTOR__}",
        "{__VITEST_ERROR_CATCHER__}",
        "{__VITEST_SCRIPTS__}",
        `<script type="module" crossorigin src="${base}${jsEntry}"><\/script>`
      ].join("\n")
    );
  }
  return replacer(baseHtml, {
    __VITEST_FAVICON__: server.faviconUrl,
    __VITEST_TITLE__: "Vitest Browser Runner",
    __VITEST_SCRIPTS__: server.orchestratorScripts,
    __VITEST_INJECTOR__: `<script type="module">${injector}<\/script>`,
    __VITEST_ERROR_CATCHER__: `<script type="module" src="${server.errorCatcherPath}"><\/script>`,
    __VITEST_CONTEXT_ID__: JSON.stringify(contextId)
  });
}

async function resolveTester(server, url, res) {
  const csp = res.getHeader("Content-Security-Policy");
  if (typeof csp === "string") {
    res.setHeader(
      "Content-Security-Policy",
      csp.replace(/frame-ancestors [^;]+/, "frame-ancestors *")
    );
  }
  const { contextId, testFile } = server.resolveTesterUrl(url.pathname);
  const project = server.project;
  const state = server.state;
  const testFiles = await project.globTestFiles();
  const tests = testFile === "__vitest_all__" || !testFiles.includes(testFile) ? "__vitest_browser_runner__.files" : JSON.stringify([testFile]);
  const iframeId = JSON.stringify(testFile);
  const context = state.getContext(contextId);
  const files = context?.files ?? [];
  const method = context?.method ?? "run";
  const injectorJs = typeof server.injectorJs === "string" ? server.injectorJs : await server.injectorJs;
  const injector = replacer(injectorJs, {
    __VITEST_PROVIDER__: JSON.stringify(server.provider.name),
    __VITEST_CONFIG__: JSON.stringify(server.getSerializableConfig()),
    __VITEST_FILES__: JSON.stringify(files),
    __VITEST_VITE_CONFIG__: JSON.stringify({
      root: server.vite.config.root
    }),
    __VITEST_TYPE__: '"tester"',
    __VITEST_CONTEXT_ID__: JSON.stringify(contextId),
    __VITEST_TESTER_ID__: JSON.stringify(crypto.randomUUID()),
    __VITEST_PROVIDED_CONTEXT__: JSON.stringify(stringify(project.getProvidedContext()))
  });
  if (!server.testerScripts) {
    const testerScripts = await server.formatScripts(
      project.config.browser.testerScripts
    );
    const clientScript = `<script type="module" src="${server.project.config.base || "/"}@vite/client"><\/script>`;
    const stateJs = typeof server.stateJs === "string" ? server.stateJs : await server.stateJs;
    const stateScript = `<script type="module">${stateJs}<\/script>`;
    server.testerScripts = `${stateScript}${clientScript}${testerScripts}`;
  }
  const testerHtml = typeof server.testerHtml === "string" ? server.testerHtml : await server.testerHtml;
  return replacer(testerHtml, {
    __VITEST_FAVICON__: server.faviconUrl,
    __VITEST_TITLE__: "Vitest Browser Tester",
    __VITEST_SCRIPTS__: server.testerScripts,
    __VITEST_INJECTOR__: `<script type="module">${injector}<\/script>`,
    __VITEST_ERROR_CATCHER__: `<script type="module" src="${server.errorCatcherPath}"><\/script>`,
    __VITEST_APPEND__: `<script type="module">
__vitest_browser_runner__.runningFiles = ${tests}
__vitest_browser_runner__.iframeId = ${iframeId}
__vitest_browser_runner__.${method === "run" ? "runTests" : "collectTests"}(__vitest_browser_runner__.runningFiles)
<\/script>`
  });
}

var BrowserPlugin = (browserServer, base = "/") => {
  const pkgRoot = resolve(fileURLToPath(import.meta.url), "../..");
  const distRoot = resolve(pkgRoot, "dist");
  const project = browserServer.project;
  return [
    {
      enforce: "pre",
      name: "vitest:browser",
      async configureServer(server) {
        browserServer.setServer(server);
        server.middlewares.use(function vitestHeaders(_req, res, next) {
          const headers = server.config.server.headers;
          if (headers) {
            for (const name in headers) {
              res.setHeader(name, headers[name]);
            }
          }
          next();
        });
        server.middlewares.use(async function vitestBrowserMode(req, res, next) {
          if (!req.url || !browserServer.provider) {
            return next();
          }
          const url = new URL(req.url, "http://localhost");
          if (!url.pathname.startsWith(browserServer.prefixTesterUrl) && url.pathname !== base) {
            return next();
          }
          res.setHeader(
            "Cache-Control",
            "no-cache, max-age=0, must-revalidate"
          );
          res.setHeader("Content-Type", "text/html; charset=utf-8");
          res.removeHeader("X-Frame-Options");
          if (url.pathname === base) {
            const html2 = await resolveOrchestrator(browserServer, url, res);
            res.write(html2, "utf-8");
            res.end();
            return;
          }
          const html = await resolveTester(browserServer, url, res);
          res.write(html, "utf-8");
          res.end();
        });
        server.middlewares.use(
          `${base}favicon.svg`,
          (_, res) => {
            const content = readFileSync(resolve(distRoot, "client/favicon.svg"));
            res.write(content, "utf-8");
            res.end();
          }
        );
        const coverageFolder = resolveCoverageFolder(project);
        const coveragePath = coverageFolder ? coverageFolder[1] : void 0;
        if (coveragePath && base === coveragePath) {
          throw new Error(
            `The ui base path and the coverage path cannot be the same: ${base}, change coverage.reportsDirectory`
          );
        }
        if (coverageFolder) {
          server.middlewares.use(
            coveragePath,
            sirv(coverageFolder[0], {
              single: true,
              dev: true,
              setHeaders: (res) => {
                res.setHeader(
                  "Cache-Control",
                  "public,max-age=0,must-revalidate"
                );
              }
            })
          );
        }
        const screenshotFailures = project.config.browser.ui && project.config.browser.screenshotFailures;
        if (screenshotFailures) {
          server.middlewares.use(`${base}__screenshot-error`, function vitestBrowserScreenshotError(req, res) {
            if (!req.url || !browserServer.provider) {
              res.statusCode = 404;
              res.end();
              return;
            }
            const url = new URL(req.url, "http://localhost");
            const file = url.searchParams.get("file");
            if (!file) {
              res.statusCode = 404;
              res.end();
              return;
            }
            let stat;
            try {
              stat = lstatSync(file);
            } catch {
            }
            if (!stat?.isFile()) {
              res.statusCode = 404;
              res.end();
              return;
            }
            const ext = extname(file);
            const buffer = readFileSync(file);
            res.setHeader(
              "Cache-Control",
              "public,max-age=0,must-revalidate"
            );
            res.setHeader("Content-Length", buffer.length);
            res.setHeader("Content-Type", ext === "jpeg" || ext === "jpg" ? "image/jpeg" : ext === "webp" ? "image/webp" : "image/png");
            res.end(buffer);
          });
        }
      }
    },
    {
      name: "vitest:browser:tests",
      enforce: "pre",
      async config() {
        const allTestFiles = await project.globTestFiles();
        const browserTestFiles = allTestFiles.filter(
          (file) => getFilePoolName(project, file) === "browser"
        );
        const setupFiles = toArray(project.config.setupFiles);
        const define = {};
        for (const env in project.config.env || {}) {
          const stringValue = JSON.stringify(project.config.env[env]);
          define[`process.env.${env}`] = stringValue;
          define[`import.meta.env.${env}`] = stringValue;
        }
        const entries = [
          ...browserTestFiles,
          ...setupFiles,
          resolve(distDir, "index.js"),
          resolve(distDir, "browser.js"),
          resolve(distDir, "runners.js"),
          resolve(distDir, "utils.js"),
          ...project.config.snapshotSerializers || []
        ];
        if (project.config.diff) {
          entries.push(project.config.diff);
        }
        if (project.ctx.coverageProvider) {
          const coverage = project.ctx.config.coverage;
          const provider = coverage.provider;
          if (provider === "v8") {
            const path = tryResolve("@vitest/coverage-v8", [project.ctx.config.root]);
            if (path) {
              entries.push(path);
            }
          } else if (provider === "istanbul") {
            const path = tryResolve("@vitest/coverage-istanbul", [project.ctx.config.root]);
            if (path) {
              entries.push(path);
            }
          } else if (provider === "custom" && coverage.customProviderModule) {
            entries.push(coverage.customProviderModule);
          }
        }
        return {
          define,
          resolve: {
            dedupe: ["vitest"]
          },
          optimizeDeps: {
            entries,
            exclude: [
              "vitest",
              "vitest/utils",
              "vitest/browser",
              "vitest/runners",
              "@vitest/browser",
              "@vitest/browser/client",
              "@vitest/utils",
              "@vitest/utils/source-map",
              "@vitest/runner",
              "@vitest/spy",
              "@vitest/utils/error",
              "@vitest/snapshot",
              "@vitest/expect",
              "std-env",
              "tinybench",
              "tinyspy",
              "tinyrainbow",
              "pathe",
              "msw",
              "msw/browser"
            ],
            include: [
              "vitest > @vitest/snapshot > magic-string",
              "vitest > chai",
              "vitest > chai > loupe",
              "vitest > @vitest/utils > loupe",
              "@vitest/browser > @testing-library/user-event",
              "@vitest/browser > @testing-library/dom"
            ]
          }
        };
      },
      async resolveId(id) {
        if (!/\?browserv=\w+$/.test(id)) {
          return;
        }
        let useId = id.slice(0, id.lastIndexOf("?"));
        if (useId.startsWith("/@fs/")) {
          useId = useId.slice(5);
        }
        if (/^\w:/.test(useId)) {
          useId = useId.replace(/\\/g, "/");
        }
        return useId;
      }
    },
    {
      name: "vitest:browser:resolve-virtual",
      async resolveId(rawId) {
        if (rawId === "/__vitest_msw__") {
          return this.resolve("msw/mockServiceWorker.js", distRoot, {
            skipSelf: true
          });
        }
      }
    },
    {
      name: "vitest:browser:assets",
      resolveId(id) {
        if (id.startsWith("/__vitest_browser__/") || id.startsWith("/__vitest__/")) {
          return resolve(distRoot, "client", id.slice(1));
        }
      },
      transform(code, id) {
        if (id.includes(browserServer.vite.config.cacheDir) && id.includes("loupe.js")) {
          const utilRequire = "nodeUtil = require_util();";
          return code.replace(utilRequire, " ".repeat(utilRequire.length));
        }
      }
    },
    BrowserContext(browserServer),
    DynamicImport(),
    {
      name: "vitest:browser:config",
      enforce: "post",
      async config(viteConfig) {
        // Enables using ignore hint for coverage providers with @preserve keyword
        viteConfig.esbuild ||= {};
        viteConfig.esbuild.legalComments = "inline";
        const server = resolveApiServerConfig(
          viteConfig.test?.browser || {},
          defaultBrowserPort
        ) || {
          port: defaultBrowserPort
        };
        server.middlewareMode = false;
        viteConfig.server = {
          ...viteConfig.server,
          ...server,
          open: false
        };
        viteConfig.server.fs ??= {};
        viteConfig.server.fs.allow = viteConfig.server.fs.allow || [];
        viteConfig.server.fs.allow.push(
          ...resolveFsAllow(
            project.ctx.config.root,
            project.ctx.server.config.configFile
          ),
          distRoot
        );
        return {
          resolve: {
            alias: viteConfig.test?.alias
          }
        };
      }
    },
    // TODO: remove this when @testing-library/vue supports ESM
    {
      name: "vitest:browser:support-testing-library",
      config() {
        return {
          define: {
            // testing-library/preact
            "process.env.PTL_SKIP_AUTO_CLEANUP": !!process.env.PTL_SKIP_AUTO_CLEANUP,
            // testing-library/react
            "process.env.RTL_SKIP_AUTO_CLEANUP": !!process.env.RTL_SKIP_AUTO_CLEANUP,
            "process.env?.RTL_SKIP_AUTO_CLEANUP": !!process.env.RTL_SKIP_AUTO_CLEANUP,
            // testing-library/svelte, testing-library/solid
            "process.env.STL_SKIP_AUTO_CLEANUP": !!process.env.STL_SKIP_AUTO_CLEANUP,
            // testing-library/vue
            "process.env.VTL_SKIP_AUTO_CLEANUP": !!process.env.VTL_SKIP_AUTO_CLEANUP,
            // dom.debug()
            "process.env.DEBUG_PRINT_LIMIT": process.env.DEBUG_PRINT_LIMIT || 7e3
          },
          optimizeDeps: {
            esbuildOptions: {
              plugins: [
                {
                  name: "test-utils-rewrite",
                  setup(build) {
                    build.onResolve({ filter: /@vue\/test-utils/ }, (args) => {
                      const _require2 = getRequire();
                      const resolved = _require2.resolve(args.path, {
                        paths: [args.importer]
                      });
                      return { path: resolved };
                    });
                  }
                }
              ]
            }
          }
        };
      }
    }
  ];
};
function tryResolve(path, paths) {
  try {
    const _require2 = getRequire();
    return _require2.resolve(path, { paths });
  } catch {
    return void 0;
  }
}
let _require;
function getRequire() {
  if (!_require) {
    _require = createRequire(import.meta.url);
  }
  return _require;
}
function resolveCoverageFolder(project) {
  const options = project.ctx.config;
  const htmlReporter = options.coverage?.enabled ? toArray(options.coverage.reporter).find((reporter) => {
    if (typeof reporter === "string") {
      return reporter === "html";
    }
    return reporter[0] === "html";
  }) : void 0;
  if (!htmlReporter) {
    return void 0;
  }
  const root = resolve(
    options.root || process.cwd(),
    options.coverage.reportsDirectory || coverageConfigDefaults.reportsDirectory
  );
  const subdir = Array.isArray(htmlReporter) && htmlReporter.length > 1 && "subdir" in htmlReporter[1] ? htmlReporter[1].subdir : void 0;
  if (!subdir || typeof subdir !== "string") {
    return [root, `/${basename(root)}/`];
  }
  return [resolve(root, subdir), `/${basename(root)}/${subdir}/`];
}

const debug = createDebugger("vitest:browser:pool");
function createBrowserPool(ctx) {
  const providers = /* @__PURE__ */ new Set();
  const waitForTests = async (method, contextId, project, files) => {
    const context = project.browser.state.createAsyncContext(method, contextId, files);
    return await context;
  };
  const executeTests = async (method, project, files) => {
    ctx.state.clearFiles(project, files);
    const browser = project.browser;
    const threadsCount = getThreadsCount(project);
    const provider = browser.provider;
    providers.add(provider);
    const resolvedUrls = browser.vite.resolvedUrls;
    const origin = resolvedUrls?.local[0] ?? resolvedUrls?.network[0];
    if (!origin) {
      throw new Error(
        `Can't find browser origin URL for project "${project.getName()}" when running tests for files "${files.join('", "')}"`
      );
    }
    const filesPerThread = Math.ceil(files.length / threadsCount);
    const chunks = [];
    for (let i = 0; i < files.length; i += filesPerThread) {
      const chunk = files.slice(i, i + filesPerThread);
      chunks.push(chunk);
    }
    debug?.(
      `[%s] Running %s tests in %s chunks (%s threads)`,
      project.getName() || "core",
      files.length,
      chunks.length,
      threadsCount
    );
    const orchestrators = [...browser.state.orchestrators.entries()];
    const promises = [];
    chunks.forEach((files2, index) => {
      if (orchestrators[index]) {
        const [contextId, orchestrator] = orchestrators[index];
        debug?.(
          "Reusing orchestrator (context %s) for files: %s",
          contextId,
          [...files2.map((f) => relative(project.config.root, f))].join(", ")
        );
        const promise = waitForTests(method, contextId, project, files2);
        promises.push(promise);
        orchestrator.createTesters(files2);
      } else {
        const contextId = crypto.randomUUID();
        const waitPromise = waitForTests(method, contextId, project, files2);
        debug?.(
          "Opening a new context %s for files: %s",
          contextId,
          [...files2.map((f) => relative(project.config.root, f))].join(", ")
        );
        const url = new URL("/", origin);
        url.searchParams.set("contextId", contextId);
        const page = provider.openPage(contextId, url.toString()).then(() => waitPromise);
        promises.push(page);
      }
    });
    await Promise.all(promises);
  };
  const runWorkspaceTests = async (method, specs) => {
    const groupedFiles = /* @__PURE__ */ new Map();
    for (const [project, file] of specs) {
      const files = groupedFiles.get(project) || [];
      files.push(file);
      groupedFiles.set(project, files);
    }
    let isCancelled = false;
    ctx.onCancel(() => {
      isCancelled = true;
    });
    for (const [project, files] of groupedFiles.entries()) {
      if (isCancelled) {
        break;
      }
      await executeTests(method, project, files);
    }
  };
  const numCpus = typeof nodeos.availableParallelism === "function" ? nodeos.availableParallelism() : nodeos.cpus().length;
  function getThreadsCount(project) {
    const config = project.config.browser;
    if (!config.headless || !project.browser.provider.supportsParallelism) {
      return 1;
    }
    if (!config.fileParallelism) {
      return 1;
    }
    return ctx.config.watch ? Math.max(Math.floor(numCpus / 2), 1) : Math.max(numCpus - 1, 1);
  }
  return {
    name: "browser",
    async close() {
      await Promise.all([...providers].map((provider) => provider.close()));
      providers.clear();
    },
    runTests: (files) => runWorkspaceTests("run", files),
    collectTests: (files) => runWorkspaceTests("collect", files)
  };
}

async function createBrowserServer(project, configFile, prePlugins = [], postPlugins = []) {
  const server = new BrowserServer(project, "/");
  const root = project.config.root;
  await project.ctx.packageInstaller.ensureInstalled("@vitest/browser", root);
  const configPath = typeof configFile === "string" ? configFile : false;
  const vite = await createServer({
    ...project.options,
    // spread project config inlined in root workspace config
    base: "/",
    logLevel: process.env.VITEST_BROWSER_DEBUG ?? "info",
    mode: project.config.mode,
    configFile: configPath,
    // watch is handled by Vitest
    server: {
      hmr: false,
      watch: null
    },
    plugins: [
      ...prePlugins,
      ...project.options?.plugins || [],
      BrowserPlugin(server),
      ...postPlugins
    ]
  });
  await vite.listen();
  setupBrowserRpc(server);
  return server;
}

export { createBrowserPool, createBrowserServer };
