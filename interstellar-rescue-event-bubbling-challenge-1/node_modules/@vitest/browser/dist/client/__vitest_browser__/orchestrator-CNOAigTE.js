var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import { _ as __vitePreload, g as getBrowserState, a as getConfig, r as relative } from "./preload-helper-Btt6SgIy.js";
import { channel, client, globalChannel } from "@vitest/browser/client";
function generateHash(str) {
  let hash = 0;
  if (str.length === 0) {
    return `${hash}`;
  }
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash;
  }
  return `${hash}`;
}
function getUiAPI() {
  return window.__vitest_ui_api__;
}
function createModuleMocker() {
  const mocks = /* @__PURE__ */ new Map();
  let started = false;
  let startPromise;
  async function init() {
    if (started) {
      return;
    }
    if (startPromise) {
      return startPromise;
    }
    startPromise = Promise.all([
      __vitePreload(() => import("msw/browser"), true ? [] : void 0),
      __vitePreload(() => import("msw/core/http"), true ? [] : void 0)
    ]).then(([{ setupWorker }, { http }]) => {
      const worker = setupWorker(
        http.get(/.+/, async ({ request }) => {
          const path = cleanQuery(request.url.slice(location.origin.length));
          if (!mocks.has(path)) {
            if (path.includes("/deps/")) {
              return fetch(bypass(request));
            }
            return passthrough();
          }
          const mock = mocks.get(path);
          if (mock === void 0) {
            const exports = await getFactoryExports(path);
            const module = `const module = __vitest_mocker__.get('${path}');`;
            const keys = exports.map((name) => {
              if (name === "default") {
                return `export default module['default'];`;
              }
              return `export const ${name} = module['${name}'];`;
            }).join("\n");
            const text = `${module}
${keys}`;
            return new Response(text, {
              headers: {
                "Content-Type": "application/javascript"
              }
            });
          }
          if (typeof mock === "string") {
            return Response.redirect(mock);
          }
          return Response.redirect(injectQuery(path, "mock=auto"));
        })
      );
      return worker.start({
        serviceWorker: {
          url: "/__vitest_msw__"
        },
        quiet: true
      });
    }).finally(() => {
      started = true;
      startPromise = void 0;
    });
    await startPromise;
  }
  return {
    async mock(event) {
      await init();
      event.paths.forEach((path) => mocks.set(path, event.mock));
      channel.postMessage({ type: "mock:done" });
    },
    async unmock(event) {
      await init();
      event.paths.forEach((path) => mocks.delete(path));
      channel.postMessage({ type: "unmock:done" });
    },
    invalidate() {
      mocks.clear();
    }
  };
}
function getFactoryExports(id) {
  channel.postMessage({
    type: "mock-factory:request",
    id
  });
  return new Promise((resolve, reject) => {
    channel.addEventListener(
      "message",
      function onMessage(e) {
        if (e.data.type === "mock-factory:response") {
          resolve(e.data.exports);
          channel.removeEventListener("message", onMessage);
        }
        if (e.data.type === "mock-factory:error") {
          reject(e.data.error);
          channel.removeEventListener("message", onMessage);
        }
      }
    );
  });
}
const timestampRegexp = /(\?|&)t=\d{13}/;
const versionRegexp = /(\?|&)v=\w{8}/;
function cleanQuery(url2) {
  return url2.replace(timestampRegexp, "").replace(versionRegexp, "");
}
function passthrough() {
  return new Response(null, {
    status: 302,
    statusText: "Passthrough",
    headers: {
      "x-msw-intention": "passthrough"
    }
  });
}
function bypass(request) {
  const clonedRequest = request.clone();
  clonedRequest.headers.set("x-msw-intention", "bypass");
  const cacheControl = clonedRequest.headers.get("cache-control");
  if (cacheControl) {
    clonedRequest.headers.set(
      "cache-control",
      // allow reinvalidation of the cache so mocks can be updated
      cacheControl.replace(", immutable", "")
    );
  }
  return clonedRequest;
}
const postfixRE = /[?#].*$/;
function cleanUrl(url2) {
  return url2.replace(postfixRE, "");
}
const replacePercentageRE = /%/g;
function injectQuery(url2, queryToInject) {
  const resolvedUrl = new URL(
    url2.replace(replacePercentageRE, "%25"),
    location.href
  );
  const { search, hash } = resolvedUrl;
  const pathname = cleanUrl(url2);
  return `${pathname}?${queryToInject}${search ? `&${search.slice(1)}` : ""}${hash ?? ""}`;
}
const url = new URL(location.href);
const ID_ALL = "__vitest_all__";
class IframeOrchestrator {
  constructor() {
    __publicField(this, "cancelled", false);
    __publicField(this, "runningFiles", /* @__PURE__ */ new Set());
    __publicField(this, "mocker", createModuleMocker());
    __publicField(this, "iframes", /* @__PURE__ */ new Map());
  }
  async init() {
    const testFiles = getBrowserState().files;
    debug("test files", testFiles.join(", "));
    this.runningFiles.clear();
    testFiles.forEach((file) => this.runningFiles.add(file));
    channel.addEventListener(
      "message",
      (e) => this.onIframeEvent(e)
    );
    globalChannel.addEventListener(
      "message",
      (e) => this.onGlobalChannelEvent(e)
    );
  }
  async createTesters(testFiles) {
    this.cancelled = false;
    this.runningFiles.clear();
    testFiles.forEach((file) => this.runningFiles.add(file));
    const config = getConfig();
    const container = await getContainer(config);
    if (config.browser.ui) {
      container.className = "scrolls";
      container.textContent = "";
    }
    const { width, height } = config.browser.viewport;
    this.iframes.forEach((iframe) => iframe.remove());
    this.iframes.clear();
    if (config.isolate === false) {
      const iframe = this.createIframe(container, ID_ALL);
      await setIframeViewport(iframe, width, height);
      return;
    }
    for (const file of testFiles) {
      if (this.cancelled) {
        done();
        return;
      }
      const iframe = this.createIframe(container, file);
      await setIframeViewport(iframe, width, height);
      await new Promise((resolve) => {
        channel.addEventListener(
          "message",
          function handler(e) {
            if (e.data.type === "done" || e.data.type === "error") {
              channel.removeEventListener("message", handler);
              resolve();
            }
          }
        );
      });
    }
  }
  createIframe(container, file) {
    if (this.iframes.has(file)) {
      this.iframes.get(file).remove();
      this.iframes.delete(file);
    }
    const iframe = document.createElement("iframe");
    iframe.setAttribute("loading", "eager");
    iframe.setAttribute(
      "src",
      `${url.pathname}__vitest_test__/__test__/${getBrowserState().contextId}/${encodeURIComponent(file)}`
    );
    iframe.setAttribute("data-vitest", "true");
    iframe.style.display = "block";
    iframe.style.border = "none";
    iframe.style.zIndex = "1";
    iframe.style.position = "relative";
    iframe.setAttribute("allowfullscreen", "true");
    iframe.setAttribute("allow", "clipboard-write;");
    iframe.setAttribute("name", "vitest-iframe");
    this.iframes.set(file, iframe);
    container.appendChild(iframe);
    return iframe;
  }
  async onGlobalChannelEvent(e) {
    debug("global channel event", JSON.stringify(e.data));
    switch (e.data.type) {
      case "cancel": {
        this.cancelled = true;
        break;
      }
    }
  }
  async onIframeEvent(e) {
    var _a;
    debug("iframe event", JSON.stringify(e.data));
    switch (e.data.type) {
      case "viewport": {
        const { width, height, id } = e.data;
        const iframe = this.iframes.get(id);
        if (!iframe) {
          const error = new Error(`Cannot find iframe with id ${id}`);
          channel.postMessage({
            type: "viewport:fail",
            id,
            error: error.message
          });
          await client.rpc.onUnhandledError(
            {
              name: "Teardown Error",
              message: error.message
            },
            "Teardown Error"
          );
          return;
        }
        await setIframeViewport(iframe, width, height);
        channel.postMessage({ type: "viewport:done", id });
        break;
      }
      case "done": {
        const filenames = e.data.filenames;
        filenames.forEach((filename) => this.runningFiles.delete(filename));
        if (!this.runningFiles.size) {
          const ui = getUiAPI();
          if (ui && filenames.length > 1) {
            const id = generateFileId(filenames[filenames.length - 1]);
            ui.setCurrentFileId(id);
          }
          await done();
        } else {
          const iframeId = e.data.id;
          (_a = this.iframes.get(iframeId)) == null ? void 0 : _a.remove();
          this.iframes.delete(iframeId);
        }
        break;
      }
      case "error": {
        const iframeId = e.data.id;
        this.iframes.delete(iframeId);
        await client.rpc.onUnhandledError(e.data.error, e.data.errorType);
        if (iframeId === ID_ALL) {
          this.runningFiles.clear();
        } else {
          this.runningFiles.delete(iframeId);
        }
        if (!this.runningFiles.size) {
          await done();
        }
        break;
      }
      case "mock:invalidate":
        this.mocker.invalidate();
        break;
      case "unmock":
        await this.mocker.unmock(e.data);
        break;
      case "mock":
        await this.mocker.mock(e.data);
        break;
      case "mock-factory:error":
      case "mock-factory:response":
        break;
      default: {
        e.data;
        await client.rpc.onUnhandledError(
          {
            name: "Unexpected Event",
            message: `Unexpected event: ${e.data.type}`
          },
          "Unexpected Event"
        );
        await done();
      }
    }
  }
}
const orchestrator = new IframeOrchestrator();
let promiseTesters;
getBrowserState().createTesters = async (files) => {
  await promiseTesters;
  promiseTesters = orchestrator.createTesters(files).finally(() => {
    promiseTesters = void 0;
  });
  await promiseTesters;
};
async function done() {
  await client.rpc.finishBrowserTests(getBrowserState().contextId);
}
async function getContainer(config) {
  if (config.browser.ui) {
    const element = document.querySelector("#tester-ui");
    if (!element) {
      return new Promise((resolve) => {
        setTimeout(() => {
          resolve(getContainer(config));
        }, 30);
      });
    }
    return element;
  }
  return document.querySelector("#vitest-tester");
}
client.waitForConnection().then(async () => {
  const testFiles = getBrowserState().files;
  await orchestrator.init();
  if (testFiles.length) {
    await orchestrator.createTesters(testFiles);
  }
});
function generateFileId(file) {
  const config = getConfig();
  const project = config.name || "";
  const path = relative(config.root, file);
  return generateHash(`${path}${project}`);
}
async function setIframeViewport(iframe, width, height) {
  const ui = getUiAPI();
  if (ui) {
    await ui.setIframeViewport(width, height);
  } else {
    iframe.style.width = `${width}px`;
    iframe.style.height = `${height}px`;
  }
}
function debug(...args) {
  const debug2 = getConfig().env.VITEST_BROWSER_DEBUG;
  if (debug2 && debug2 !== "false") {
    client.rpc.debug(...args.map(String));
  }
}
